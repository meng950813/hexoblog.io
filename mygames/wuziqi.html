<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>五子棋</title>
	<style>
		*{
			margin: 0;
			padding: 0;
		}
		#container{}
		canvas{
			position: absolute;
			top: 50%;
			left: 50%;
			margin:-225px -225px; 
			box-shadow: -2px -2px 2px #efefef,5px 5px 5px #b9b9b9; 
		}
	</style>
</head>
<body>
	<div id="container">
		<canvas id="chess" width="450px" height="450px"></canvas>
	</div>
	<script type="text/javascript" src="js/srcipt.js"></script>
</body>
<script type="text/javascript">
	var content = document.getElementById('chess');
var chess = content.getContext('2d');

// 行数
var lineNum = 15;
//最多落子数
var sumCount = lineNum*lineNum;
// 当前落子数
var nowCount = 0;

//标注落子颜色
var me = true;
//存储落子情况，防止棋子覆盖，二维数组
var chessBoard = [];
//初始化落子数组
for (var i = 0; i < lineNum; i++) {
	chessBoard[i] = [];
	for(var j=0;j<lineNum;j++){
		chessBoard[i][j] = 0;
	}
}

//赢法数组，记录所有可能的赢法，三维数组
var wins = [];
//初始化赢法数组
for(var i=0;i<lineNum;i++){
	wins[i] = [];
	for(var j=0;j<lineNum;j++){
		wins[i][j] = [];
	}
}
var count = 0; //表示第count种赢法
//五子在一条横线
for (var i = 0; i < lineNum; i++) {
	for(var j=0;j<lineNum-4;j++){
		for(var k=0;k<5;k++){
			wins[i][j+k][count]=true;
		}
	count++;
	}
}
//五子在一条竖线
for (var i = 0; i < lineNum; i++) {
	for(var j=0;j< lineNum-4;j++){
		for(var k=0;k<5;k++){
			wins[j+k][i][count]=true;
		}
	count++;
	}
}
//五子在一条斜线
for (var i = 0; i < lineNum-4; i++) {
	for(var j=0;j<lineNum-4;j++){
		for(var k=0;k<5;k++){
			wins[i+k][j+k][count]=true;
		}
	count++;
	}
}
//五子在一条反斜线
for (var i = 0; i < lineNum-4; i++) {
	for(var j=lineNum-1;j>lineNum-12;j--){
		for(var k=0;k<5;k++){
			wins[i+k][j-k][count]=true;
		}
	count++;
	}
}
console.log("count ="+count);
//赢法统计数组
var myWin = [];
var computerWin = [];

// 初始化赢法统计数组
for(var i=0;i<count ;i++){
	myWin[i]=0;
	computerWin[i]=0;
}

chess.strokeStyle = '#BFBFBF';

//画线
var drawChessBoard = function(){
	for(var i=0; i<lineNum; i++){
		//纵线
		chess.moveTo(15+ i*30, 15);
		chess.lineTo(15+ i*30, 435);
		chess.stroke();

		// 横线
		chess.moveTo(15,15+i*30);
		chess.lineTo(435,15+i*30);
		chess.stroke();
	}
}
drawChessBoard();

var oneStep = function(x, y, me){
	chess.beginPath();
	chess.arc(15+x*30,15+y*30,12,0,2*Math.PI);
	//颜色渐变， +2 ,-2 表示渐变向右下方偏移
	var gradient = chess.createRadialGradient(15+x*30+2,15+y*30-2,12,5+x*30+2,15+y*30-2,0);
	if(me){
		//黑棋
		gradient.addColorStop(0,"#0A0A0A");
		gradient.addColorStop(1,"#636766");
	}
	else{
		//白棋
		gradient.addColorStop(0,"#d1d1d1");
		gradient.addColorStop(1,"#f9f9f9");
	}
	chess.closePath();

	chess.fillStyle=gradient;
	chess.fill();
	//当前棋盘总棋子数 +1
	nowCount++;
}

//表示当前是否结束
var over =false;

content.onclick = function(e){
	// console.log("click");
	if(over){
		if(confirm("是否重新开始")){
			location.reload();
		}
		else{
			return;
		}
	}
	if(!me){
		return;
	}
	var x = e.offsetX;
	var y = e.offsetY;
	//向下取整
	var i = Math.floor(x/30);
	var j = Math.floor(y/30);
	if(chessBoard[i][j]==0){
		oneStep(i,j,me);
		chessBoard[i][j]=1;
		for(var k=0;k<count;k++){
			if(wins[i][j][k]){
				myWin[k]++;
				//表示这种赢法不可能
				computerWin[k]=6;
				if(myWin[k]==5){
					alert("你赢了！");
					over =true;
				}
			}
		}
		if(!over){
			me=(!me);
			computerAI();
		}
	}
}

var computerAI = function(){
	var myScore = [];
	var computerScore = [];
	var max = 0;
	var u = 0,v = 0;
	for(var i=0; i<lineNum; i++){
		myScore[i] =[];
		computerScore[i] =[];
		for(var j=0; j<lineNum; j++){
			myScore[i][j]=0;
			computerScore[i][j]=0;
		}
	}

	for(var i=0; i<lineNum; i++){
		for(var j=0; j<lineNum; j++){
			if(chessBoard[i][j]==0){
				for(var k=0;k<count; k++){
					if(wins[i][j][k]){
						//拦截
						switch(myWin[k]){
							case 1:
								myScore[i][j] += 200;
								break;
							case 2:
								myScore[i][j] += 400;
								break;
							case 3:
								myScore[i][j] += 1000;
								break;
							case 4:
								myScore[i][j] += 10000;
								break;
							default:
								break;
						}
						//计算机落子
						switch(computerWin[k]){
							case 1:
								computerScore[i][j] += 220;
								break;
							case 2:
								computerScore[i][j] += 420;
								break;
							case 3:
								computerScore[i][j] += 2000;
								break;
							case 4:
								computerScore[i][j] += 20000;
								break;
							default:
								break;
						}
					}
					
				}
				if(myScore[i][j] > max){
					max = myScore[i][j];
					u = i;
					v = j;
				}else if(myScore[i][j] == max){
					if(computerScore[i][j] > computerScore[u][v]){
						u = i;
						v = j;
					}
				}

				if(computerScore[i][j] > max){
					max = computerScore[i][j];
					u = i;
					v = j;
				}else if(computerScore[i][j] == max){
					if(myScore[i][j] > myScore[u][v]){
						u = i;
						v = j;
					}
				}
			}
		}
	}
	oneStep(u,v,false);
	chessBoard[u][v] = 2;
	for(var k=0; k<count; k++){
		if(wins[u][v][k]){
			computerWin[k]++;
			//表示这种赢法不可能
			myWin[k]=6;
			if(computerWin[k] == 5){
				alert("计算机赢了！");
				over = true;
			}else if(nowCount == sumCount){
				alert("平局");
			}
		}
	}
	if(!over){
		// console.log("me = "+me);
		me=(!me);
	}
}
</script>
</html>