[{"title":"Docker安装Neo4j","date":"2020-02-15T06:11:45.000Z","path":"2020/02/15/docker安装Neo4j/","text":"操作内容 Docker创建Neo4j的容器 导入已有数据库 创建过程中的注意事项 1. Docker创建Neo4j的容器12345678910111213141516# 搜索镜像docker search neo4j# 获取镜像docker pull neo4j:版本号# 创建容器docker run \\ --name neo4j \\ # 容器名 -p7474:7474 -p7687:7687 \\ # 端口映射 -d \\ # 后台运行 -v $HOME/neo4j/data:/data \\ # 挂载数据库文件 =&gt; graph.db -v $HOME/neo4j/logs:/logs \\ -v $HOME/neo4j/import:/var/lib/neo4j/import \\ -v $HOME/neo4j/plugins:/plugins \\ -e NEO4j_dbms_memory_pagecache_size=1G \\ 设置缓存区，以提高查询效率 --env NEO4J_AUTH=username/password \\ # 设置用户名(默认neo4j)/密码 neo4j:latest # 镜像版本 这之后就可以通过 http://localhost:7474/browser/ 这个地址访问 Neo4j Server 的 WebUI，可以在上面查询、修改数据。 导入已有数据库 停止容器 docker stop 容器名/容器id 在挂载文件中替换 graph.db 文件 重启容器 详情可参考Github中提的Issus Mapping an existing local neo4j database to a neo4j docker container 注意事项 Neo4j的配置可以根据自己的情况适当地进行修改，完整的配置见文档，个人认为比较重要的几个： 认证方式设置默认情况下启动的 neo4j，会要求在访问时通过用户名密码进行认证，初始的用户名密码为 neo4j/neo4j ，同时会在第一次认证之后要求更换密码。 也可以主动设置好密码，非 docker 模式部署，需要在初次启动通过 neo4j-admin 命令设置1neo4j-admin set-initial-password neo4j_password 如果是 docker 模式部署，则在启动容器时通过环境变量 NEO4J_AUTH 来设置123456docker run -d \\ --name neo4j \\ -p 7474:7474 -p 7687:7687 \\ -v $HOME/neo4j/data/:/data \\ -e NEO4J_AUTH=neo4j/neo4j_password \\ neo4j 内存设置这块有三项设置，分别是123dbms.memory.heap.initial_sizedbms.memory.heap.max_sizedbms.memory.pagecache.size 前两者决定了查询语言运行时候可用的内存，第三个则用于缓存数据和索引以提高查询效率。非 docker 模式部署的，可以在 /conf/neo4j.conf 文件里修改123dbms.memory.heap.initial_size=1Gdbms.memory.heap.max_size=2Gdbms.memory.pagecache.size=1G docker 模式部署则还是在启动容器时通过环境变量来设置，如下所示12345678docker run -d \\ --name neo4j \\ -p 7474:7474 -p 7687:7687 \\ -v $HOME/neo4j/data/:/data \\ -e NEO4j_dbms_memory_heap_initial__size=1G \\ -e NEO4j_dbms_memory_heap_max__size=2G \\ -e NEO4j_dbms_memory_pagecache_size=1G \\ neo4j","tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://www.cmeng.cc/tags/Neo4j/"},{"name":"Docker","slug":"Docker","permalink":"http://www.cmeng.cc/tags/Docker/"}]},{"title":"leetcode 刷题记录(中等篇) NO.735 行星碰撞","date":"2018-09-21T15:33:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(中等篇)735-行星碰撞/","text":"问题描述：给定一个整数数组 asteroids，表示在同一行的行星。对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。说明： 数组 asteroids 的长度不超过 10000。 每一颗行星的大小都是非零整数，范围是 [-1000, 1000] 。 思路利用栈先进后出的特性，若栈外元素与栈顶元素发生碰撞，则这两个一定是距离最近，本该相撞的元素 伪代码 1、 定义一个栈并遍历所有陨石 2、 若栈空或栈顶元素与新元素不会相撞（陨石同向或背道而驰==&gt;栈顶负，栈外正），新元素入栈 3、 否则两陨石相撞，进行比较（此时栈顶元素一定为正）： 3.1、 若栈外陨石更大,弹出栈顶元素（陨石被撞碎）,栈外陨石继续与新栈顶元素比较 3.2、 若同样大，栈顶陨石出栈，同时栈外换下一个陨石 3.3、 若栈顶陨石大，栈不做任何操作 代码1234567891011121314151617181920212223242526# with Pythondef asteroidCollision(self, asteroids): \"\"\" :type asteroids: List[int] :rtype: List[int] \"\"\" ls = [] x = 0 while x &lt; len(asteroids): if ls == [] or (ls[-1] * asteroids[x] &gt; 0) or (ls[-1] &lt; 0 and asteroids[x] &gt; 0): ls.append(asteroids[x]) # 会撞,且栈顶陨石为正 else: # 栈内陨石被撞碎,栈外陨石继续与新栈顶陨石比较 if ls[-1] + asteroids[x] &lt; 0: ls.pop() x -= 1 # 全碎 elif t + asteroids[x] == 0: ls.pop() # else 栈外陨石被撞碎 x += 1 return ls","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"栈","slug":"栈","permalink":"http://www.cmeng.cc/tags/栈/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(简单篇) NO.455 分发饼干","date":"2018-09-21T15:31:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(简单篇)455-分发饼干/","text":"问题描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ,这是能让孩子们满足胃口的饼干的最小尺寸;并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 说明： 假设胃口值为正。 一个小朋友最多只能拥有一块饼干。 思路简单的匹配问题，只需要将两个数组排序，用孩子的胃口匹配对应的饼干，直到匹配孩子或饼干全部匹配 代码12345678910111213141516171819202122# with Pythondef findContentChildren(self, g, s): \"\"\" :type g: List[int] :type s: List[int] :rtype: int \"\"\" g = sorted(g) s = sorted(s) x, y,count = 0, 0, 0 while x &lt; len(g) and y &lt; len(s): # 孩子可以被满足 if g[x] &lt;= s[y]: count += 1 x ,y = x+1,y+1 # 不能被满足 =&gt; 换一块更大的饼干 else: y += 1 return count","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(简单篇) NO.268 缺失数字","date":"2018-09-21T13:53:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(简单篇)268-缺失数字/","text":"问题描述：给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 注意： 算法应具有线性时间复杂度。尽量仅使用额外常数空间来实现 思路排序(快排) ==&gt; O(nlogn) 查找(二分法) ==&gt; O(logn) 时间复杂度 O(nlogn) 空间复杂度 O(1) 代码12345678910111213141516171819202122# with Pythondef missingNumber(self, nums): nums = sorted(nums) # print(nums) if nums[0] != 0: return 0 if nums[-1] == len(nums)-1: return len(nums) last = 0 while len(nums) &gt; 2: mid = len(nums) // 2 if nums[mid] == mid + last: nums = nums[mid:] last += mid else: nums = nums[:mid+1] # print(nums,mid,last) return (nums[0]+nums[1])//2","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(困难篇) NO.45 跳跃游戏Ⅱ","date":"2018-09-21T05:33:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(困难篇)45-跳跃游戏 II/","text":"问题描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。 说明： 假设你总是可以到达数组的最后一个位置。 思路与 跳跃游戏（中等篇） 相同，使用贪心算法解决。即：1每次都选择所有可跳点中能跳最远的点 伪代码 1、 判断数组长度，若长度为 1 ，返回0；否则，定义 count = 0，记录跳跃次数 2、 判断当前位置能否直接跳到终点，若能，返回 count + 1 3、 遍历所有位于当前位置下一跳范围内的点，计算其能跳的最远距离 4、 选择能跳最远的点，count+1,继续步骤 2 代码12345678910111213141516171819202122232425# with Pythondef jump(self, nums): if len(nums) &lt;= 2: return len(nums)-1 position , count = 0, 0 while position &lt; len(nums): # 当前位置，可以跳到最后 if position + nums[position] + 1 &gt;= len(nums): return count + 1 # max_step: 下一跳范围内的点能达到的最远位置 # next_step: 能跳到最远位置的点 max_step ,next_step = 0, 0 for x in range(position + 1, position + nums[position] + 1): if nums[x] + x &gt; max_step: max_step = nums[x] + x next_step = x position = next_step count += 1 return count","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://www.cmeng.cc/tags/贪心算法/"}]},{"title":"leetcode刷题记录(中等篇)：NO.82 删除排序链表中的重复元素 II","date":"2018-09-21T05:33:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(中等篇)82-删除排序链表中的重复元素II/","text":"题目描述：给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现的数字。 示例 12345输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 思路需要三个指针（指针初始关系：h-&gt;pre-&gt;p): 指针 p，一往无前，遍历整个链表 指针 pre,在p之后，负责框选所有有重复值的元素 指针 h,指向上一个符合要求的元素（没有重复数字的元素），时刻准备抛弃有重复数字的节点（指针初始关系：h-&gt;pre-&gt;p) 123456781、判断链表 head==NULL || head-&gt;next == NULL（为空或单节点）,若是,返回 head;否则2、判断链表是否 只有两个 节点，若是: 2.1、若两节点相同：返回NULL3、否则（链表有多于两个节点），若仅前两个节点相同（pre-&gt;val == h-&gt;val &amp;&amp; pre-&gt;val != p-&gt;val）,递归调用以 p 头结点的链表4、否则,直到 p == NULL 时结束循环： 4.1、循环查找，直到发现与 pre 不同的节点 4.2、若有与 pre 相同的节点(pre-&gt;next != p)，舍弃 pre 到 p 之间的节点 4.3、否则。三个指针全部后移 代码12345678910111213141516171819202122232425262728293031323334// with C++ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *h = head,*pre = head-&gt;next; if(pre-&gt;next == NULL &amp;&amp; pre-&gt;val == h-&gt;val) return NULL; ListNode *p = pre-&gt;next; if(pre-&gt;val == h-&gt;val &amp;&amp; pre-&gt;val != p-&gt;val) return this-&gt;deleteDuplicates(p); while(p)&#123; while(p &amp;&amp; pre-&gt;val == p-&gt;val)&#123; // 寻找第一个不同的数 p = p-&gt;next; &#125; if(pre-&gt;next != p)&#123;// 若与pre不同的数不是pre-&gt;next，表示中间有重复数，需删除 h-&gt;next = p; pre = p; if(p!=NULL) p = p-&gt;next; &#125; else&#123; h = pre; pre = p; if(p!=NULL) p = p-&gt;next; &#125; &#125; return head;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://www.cmeng.cc/tags/C/"},{"name":"链表","slug":"链表","permalink":"http://www.cmeng.cc/tags/链表/"}]},{"title":"leetcode 刷题记录(中等篇) NO.495 提莫攻击","date":"2018-09-21T05:33:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(中等篇)495-提莫攻击/","text":"问题描述：在《英雄联盟》的世界中，有一个叫“提莫”的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。说明： 你可以假定时间序列数组的总长度不超过10000。 你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过10,000,000。 思路由题目已知给出的时间序列是有序的，省了很多事。本题只需要判断两次攻击的时间间隔与中毒时长的大小即可伪代码 1、 若数组为空(leetcode常见操作)，即没有攻击，返回0 2、 从第二个元素开始遍历数组，比较两次攻击时间差与中毒时长的大小，取其中较小的数 3、 加上最后一次攻击的中毒时长 代码12345678910111213141516171819# with Pythondef findPoisonedDuration(self, timeSeries, duration): \"\"\" :type timeSeries: List[int] :type duration: int :rtype: int \"\"\" if len(timeSeries) == 0: return 0 # 初始值为最后一次攻击的持续时间 SUM = duration for x in range(1,len(timeSeries)): if timeSeries[x] - timeSeries[x-1] &gt; duration: SUM += duration else: SUM += (timeSeries[x] - timeSeries[x-1]) return SUM","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(中等篇) NO.55 跳跃游戏","date":"2018-09-21T05:33:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(中等篇)55-跳跃游戏/","text":"问题描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 思路使用贪心算法：每次跳跃都选择覆盖范围最大的点,这样每次跳跃才有最多的选择,即覆盖全部可能的跳法。 伪代码： 1、 若数组长度为 1,则当前就在目的地，返回 true 2、 定义变量 position 表示当前所在位置 3、 循环，当 position &gt;= len(nums) 时结束循环（可有可无） 3.1、 判断当前位置的跳跃长度是否为0。若是，返回 False 3.2、 判断从当前位置能否跳跃到最终点。若能，返回 True 3.3、 遍历当前位置可跳范围内能跳最远的点作为本次跳跃的目标 代码1234567891011121314151617181920212223242526# with Pythondef canJump(self, nums): if len(nums) == 1: return True position = 0 while position &lt; len(nums): if nums[position] == 0: return False if position+nums[position]+1 &gt;= len(nums): return True # max_step : 表示当前位置所有可跳点中能跳的最远距离 # next_step: 表示本次应该跳到的位置 max_step,next_step = 0, 0 for x in range(position+1 , position+nums[position]+1): if nums[x] + x &gt; max_step: max_step = nums[x] + x next_step = x position = next_step return True","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://www.cmeng.cc/tags/贪心算法/"}]},{"title":"leetcode 刷题记录(简单篇) NO.263 丑数","date":"2018-09-21T05:23:23.000Z","path":"2018/09/21/index.md/leetcode刷题记录(简单篇)263-丑数/","text":"问题描述：编写一个程序判断给定的数是否为丑数。丑数就是只包含质因数 2, 3, 5 的正整数。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−2^31, 2^31 − 1] 思路依次除以 5，3，2，直到取模不为0，若最后结果为1 ，返回true,否则不是 代码1234567891011121314151617def isUgly(self, num): if num &lt;= 0 : return False if num == 1: return True while num % 5 == 0 and num &gt;= 5: num /= 5 while num % 3 == 0 and num &gt;= 3: num /= 3 while num % 2 == 0 and num &gt;= 2: num /= 2 return num == 1","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(困难篇) NO.906 超级回文数","date":"2018-09-20T15:33:23.000Z","path":"2018/09/20/index.md/leetcode刷题记录(困难篇)906-超级回文数/","text":"问题描述：如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。现在，给定两个正整数 L 和 R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。 注意： 1 &lt;= len(L) &lt;= 18 1 &lt;= len(R) &lt;= 18 L 和 R 是表示 [1, 10^18) 范围的整数的字符串。 int(L) &lt;= int(R) 思路考虑到数值的范围很大，暴力求解不可取，因此需要缩小范围。从两数的平方根之间判断：找出其中的回文数，判断其平方是否也是回文数即可。但是即便如此，需要判定的数字最高也有9位之多，暂时不知如何继续缩减。。。大方向做不了更多只能在小细节（判读回文数）上优化一点（参见leetcode 刷题记录（简单篇）：NO.9 回文数）。 代码123456789101112131415161718192021222324252627282930# with Pythonimport mathdef superpalindromesInRange(L, R): \"\"\" :type L: str :type R: str :rtype: int \"\"\" nl,nr = long(math.sqrt(long(L))),long(math.sqrt(long(R))) count = 0 # 筛选出 [nl,nr]之间的所有回文数 for x in filter(palindrom, range(nl,nr+1)): if palindrom(x * x): count += 1 return count# 判断是否事回文数def palindrom(s): if s % 10 == 0: return False k = 0 while k &lt; s: k = k * 10+ s % 10 if s == k or s/10 == k: return True s /= 10 return False 注意：这并不是很好的办法,事实上这也是暴力求解。上述代码为了跑出所有开方数花了15分钟左右（与python本身执行效率也有关系）。很明显这种耗时在leetcode上是过不了的，但知道所有满足情况的数之后就很容易用个取巧的办法解决：判断列表中有多少数在给定的范围中。 代码123456789101112# with Pythonls =[1,2,3,11,22,101,111,121,202,212,1001,1111,2002,10001,10101,10201,11011,11111,11211,20002,20102,100001,101101,110011,111111,200002,1000001,1001001,1002001,1010101,1011101,1012101,1100011,1101011,1102011,1110111,1111111,2000002,2001002,10000001,10011001,10100101,10111101,11000011,11011011,11100111,11111111,20000002,100000001,100010001,100020001,100101001,100111001,100121001,101000101,101010101,101020101,101101101,101111101,110000011,110010011,110020011,110101011,110111011,111000111,111010111,111101111, 111111111,200000002,200010002]nl,nr = long(math.sqrt(long(L))),long(math.sqrt(long(R)))count = 0for x in range(len(ls)): if ls[x] &gt;= nl and ls[x] &lt;= nr: count += 1return count","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(中等篇)：NO.456 132模式","date":"2018-09-20T12:23:23.000Z","path":"2018/09/20/index.md/leetcode刷题记录(中等篇)456-132模式/","text":"问题描述：给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。 注意： n 的值小于15000。 思路利用栈可以高效快速的解决该问题。需要维护一个栈和一个变量 right 。栈中保存所有比 right 大的值，即 “132” 中的 “3”,right表示 “2”,只需要再找到比right小的 “1”，即可返回true。需要从后向前遍历。当遇到比栈顶元素大的元素时，循环弹出比该元素小的所有栈顶元素，将弹出的元素赋值给 right, 这时 right 相比之前变的更大，更容易找到 “1”。 伪代码 1、 判断数组长度，小于3 直接返回 false (leetcode测试用例的老一套) 2、 定义栈和 right = INT_MIN（初始 right 为最小值） 3、 从后向前遍历数组： 3.1、 若当前元素比 right 小 ==&gt; &quot;1&quot;,返回true 3.2、 否则弹出所有比当前元素小的顶元素，并将弹出的元素赋值给 right 3.3、 将当前元素入栈 4、 循环结束，表示不含 &quot;132&quot; 模式的子序列，返回false 代码123456789101112131415161718192021// with C++ bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if (size &lt; 3) return false; stack&lt;int&gt; s; int right = INT_MIN; for(int i = size-1; i &gt;= 0; --i)&#123; if(nums[i]&lt;right) return true; // 保证栈中的元素都是大于 \"2\" 的 “3” while(!s.empty() &amp;&amp; nums[i] &gt; s.top())&#123; right = s.pop(); &#125; s.push(nums[i]); &#125; return false; &#125; 参考文档：https://leetcode.com/problems/132-pattern/discuss/94071/single-pass-c-on-space-and-time-solution-8-lines-with-detailed-explanation","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://www.cmeng.cc/tags/C/"},{"name":"栈","slug":"栈","permalink":"http://www.cmeng.cc/tags/栈/"}]},{"title":"leetcode 刷题记录(简单篇) NO.561 数组拆分I","date":"2018-09-19T12:32:23.000Z","path":"2018/09/19/index.md/leetcode刷题记录(简单篇)561-数组拆分I/","text":"问题描述：给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。说明： n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 思路既然是找所有小数的最大和，就要保证每个次大的数不能被浪费。即最大值与次大的值一组，第三大与第四大一组。。。最小值与次小值一组所以需要先排序,偶数位元素总和即为答案。 代码12345678910111213#with Pythonclass Solution(object): def arrayPairSum(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums = sorted(nums) SUM = 0 for x in range(0,len(nums),2): SUM += nums[x] return SUM","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"leetcode 刷题记录(简单篇) NO.575 分糖果","date":"2018-09-19T12:30:23.000Z","path":"2018/09/19/index.md/leetcode刷题记录(简单篇)575-分糖果/","text":"问题描述：给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。弟弟表示这个分发……没毛病说明： 数组的长度为[2, 10,000]，并且确定为偶数。 数组中数字的大小在范围[-100,000, 100,000]内。 思路排序 -&gt; 把所有糖果挑一份给妹妹 -&gt; 直到够一半或所有种类都挑完 代码123456789101112131415def distributeCandies(self, candies): \"\"\" :type candies: List[int] :rtype: int \"\"\" ls = sorted(candies) count,size = 1,len(ls)/2 for x in range(1,len(ls)): if count == size: return count if ls[x] != ls[x-1]: count += 1 return count","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"python","slug":"python","permalink":"http://www.cmeng.cc/tags/python/"}]},{"title":"Hello World","date":"2018-09-18T15:48:40.709Z","path":"2018/09/18/index.md/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"leetcode刷题记录(中等篇) NO.05 最长回文子串","date":"2018-09-18T14:36:21.000Z","path":"2018/09/18/index.md/leetcode刷题记录(中等篇)05-最长回文子串/","text":"问题描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 思路考虑到回文子串的形式只有两种： ..X.. 以及 ..XX..因此可以尝试从一个或两个坐标点开始向两边开始寻找，通过判断两边是否相同可以得出是否是回文数。 代码123456789101112131415161718192021222324252627282930// 以n1,n2为起点，向两边寻找回文字符串 string compare(string s,int n1,int n2)&#123; int to_left = n1,to_right = n2 ,len = s.size();// 直到找不到回文字符或到头结束循环 while(to_left &gt;= 0 &amp;&amp; to_right &lt; len &amp;&amp; s[to_left] == s[to_right])&#123; to_left--; to_right++; &#125; // 返回回文部分 return s.substr(to_left+1,to_right-to_left-1); &#125; string longestPalindrome(string s) &#123; int len = s.size(); if(len == 0) return \"\"; string longest=s.substr(0,1),p; for(int i = 0;i&lt;len-1;i++)&#123; // 。。X。。 形式的回文子串 p = this-&gt;compare(s,i,i); if(p.size() &gt; longest.size()) longest = p; // 。。XX。。 形式的回文子串 p = this-&gt;compare(s,i,i+1); if(p.size()&gt;longest.size()) longest = p; &#125; return longest; &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://www.cmeng.cc/tags/C/"}]},{"title":"leetcode 刷题记录(简单篇) NO.9 回文数","date":"2018-09-13T15:33:23.000Z","path":"2018/09/13/index.md/leetcode刷题记录(简单篇)09 回文数/","text":"问题描述：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数（负数的符号也计入在内 ==&gt; 负数是非回文数）。[进阶]： 不要使用将整数转换为字符串的方式解决问题 示例：123__输入:__ 121 ==&gt; true__输入:__ -121 ==&gt; false__输入:__ 10 ==&gt; false 思路1：暴力法 最常用的解题办法：将数x不断取余和取模倒序为另一个数，然后两相比较。、、、bashint n=x,m=0;while(n){ m = m*10 + x%10; x /= 10;}、、、这种解法最主要的就是注意不能让反转后的数字越界，比如 4个字节的int取值范围是-2147483648 ~ 2147483647,x=1123456789是可行的，但反转出的9876543211就超出了int的范围，会变成另一个值。可是就题目来看，如果是回文数，反转了也不会出现超出范围的情况；如果不是，就算超了也不会让他们相等的情况，这么一想，正中下怀然而leetcode事实证明 “暴力模不可取”,测试用例中包含超出int范围的数，然后就会报错 思路2：转换法 把整数转换为字符串,通过一头一尾两个指针向中间挤，如果指针相遇前出现两指针值不同的情况，即为非回文数，否则就是回文数。然而题目要求不要用。。。弃之。 思路3：截半法（名字我瞎取的）这种办法类似于暴力法,区别在于是取后半段反转与前半段比较。那么重点在于如何判断已经取到中间。最简单的办法是判断两数之间的大小：1234原数：m, 新数：n。 若：m &gt; n:表示还需要继续取余；m == n:返回 truem &lt; n:返回 false 然而这种做法对形如 121 的奇数位数无效： m=121,n=0 ==&gt; m=12,n=1 ==&gt; m=1,n=12 ==&gt; false ==&gt; GG 所以还需要在取余之前判断一下 m 与 n 最终代码1234567891011121314bool isPalindrome(int m) &#123; if(m &lt; 0 || m%10 == 0) return false; int n = 0; do&#123; n = n * 10 + m % 9; if(m == n) return true; m /= 10; &#125;while(m &gt; n); return false;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.cmeng.cc/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://www.cmeng.cc/tags/C/"}]},{"title":"禁止apache显示目录索引","date":"2017-04-01T11:45:21.000Z","path":"2017/04/01/index.md/appache-forbide-file-dir/","text":"禁止apache显示目录索引服务器上部署项目之后会显示文件索引，这很烦，也让网站很不安全，所以找办法禁止显示。下面是找到的禁止Apache显示目录索引的常见的2种方法。 方法一：修改目录配置 注：Apache修改httpd.conf，Apache2修改apache2.conf 初始配置文件如下：1234567&lt;Directory /var/www&gt; Options Indexes FollowSymLinks # 修改为： Options FollowSymLinks AllowOverride None Order allow,deny Allow from all&lt;/Directory&gt; 注：Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构,去掉 Indexes, Apache 就不会显示该目录的列表了。 方法二： 通过.htaccess文件可以在根目录新建或修改 .htaccess 文件中添加如下代码：123&lt;Files *&gt; Options -Indexes&lt;/Files&gt; 就可以禁止Apache显示目录索引。 保存修改文件，重启服务器 不会重启apache？狠狠点这里 linux配置apache","tags":[{"name":"linux","slug":"linux","permalink":"http://www.cmeng.cc/tags/linux/"},{"name":"apache","slug":"apache","permalink":"http://www.cmeng.cc/tags/apache/"},{"name":"服务器","slug":"服务器","permalink":"http://www.cmeng.cc/tags/服务器/"}]},{"title":"linux 下的 mysql 命令行操作","date":"2017-04-01T06:08:23.000Z","path":"2017/04/01/index.md/Linux-MySql/","text":"linux 下的 mysql 命令行操作突然发现又忘了服务器上的数据库怎么用的了。。。所以决定写这篇博客记录一下linux下的常用的mysql数据库命令。防忘标签注：所有命令基于ubuntu系统 linux下安装mysql 更新本地软件库的索引 1sudo apt-get update 安装数据库 1sudo apt-get install mysql-server 安装客户端 12sudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev 判断是否安装成功 1(sudo) netstat -tap|grep mysql 出现这个就是成功： 简单配置mysql 设置数据库编码 打开配置文件1sudo nano /etc/mysql/my.cof 修改如下位置12345[client]port = 3306socket = /var/run/mysqld/mysqld.sock#增加客户端的字符编码default-character-set=utf8 1234[mysqld]#增加服务器端的字符编码character-set-server=utf8collation-server=utf8_general_ci 让服务器可以远程访问，还是配置文件my.cnf12#注释bind-address#bind-address = 127.0.0.1 mysql 常用命令 启动mysql 1service mysql start 停止mysql 1service mysql stop 登录 12//-u后面跟用户名，回车之后输入密码即可mysql -u root -p 查看数据库字符集 1show variables like 'character%'; 数据库操作 创建数据库 1create database &lt;数据库名&gt;; 显示所有数据库 1show databases; 进入/切换数据库 1use &lt;数据库名&gt;; 删除数据库 1drop database &lt;数据库名&gt;; 查看当前使用数据库 1select database(); 数据库导入与导出(备份与恢复) 导入数据库 1mysql -u root -p 数据库名&lt;数据库文件; //导入时数据库必须存在，可以为空数据库 导出数据库 1mysqldump -u root -p --opt 数据库名&gt;备份名; //进入到库目录 数据库授权 1grant select,... on 数据库.* to 用户名@登录主机 identified by \"密码\"; 例-1：增加一个用户user001密码为123456，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限:1grant select,insert,update,delete on *.* to user001@\"%\" Identified by \"123456\"; 例-2:增加一个用户user002密码为123456,让此用户只可以在localhost上登录,也可以设置指定IP，并可以对数据库test进行查询、插入、修改、删除的操作 (localhost 指本地主机,即MySQL数据库所在的那台主机)//这样用户即使用知道user_2的密码，他也无法从网上直接访问数据库，只能通过MYSQL主机来操作test库。1grant select,insert,update,delete on test.* to user002@localhost identified by \"123456\"; 表操作 显示所有表 1show tables; 显示表结构 1describe &lt;表名&gt;; 建表 123456789create table &lt;表名&gt;(字段属性);例：create table name( id int auto_increment not null primary key , uname char(8) );注： auto_increment 自增 primary key 主键 foreign key(字段名) references(表名.字段名) 外键 删表 1drop table &lt;表名&gt;; 记录操作（增删改查） 增加记录 1insert into &lt;表名&gt;(字段名,...) values(字段值,...); 删除记录 1delete from &lt;表名&gt; where xxxx; 修改记录 1update &lt;表名&gt; set 字段名=\"新值\" where xxxx; 查询记录 1select xxx from &lt;表名，...&gt; where xxxx;","tags":[{"name":"linux","slug":"linux","permalink":"http://www.cmeng.cc/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://www.cmeng.cc/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://www.cmeng.cc/tags/数据库/"},{"name":"命令行","slug":"命令行","permalink":"http://www.cmeng.cc/tags/命令行/"}]},{"title":"网页上传日志","date":"2017-03-21T13:02:39.000Z","path":"2017/03/21/index.md/uploadDiary/","text":"网页上传日志本次上传内容主要是各种特效，主要是canvas特效和css特效。不久之前，楼主发现了一个有意思的网站，主要是关于各种网页特效等，原网站传送门。本文主要列举其中几个css的特效，为了防止忘记原网址也为了美化一下服务器，就自（臭）告（不）奋（要）勇（脸）的下载并修改了几个原始网页，上传到我的服务器。。。 css特效元素hover特效 Creative Link Effects Creative Button Styles Icon Hover Effects Animated SVG Icons 元素点击特效Progress Button Styles js实现特效 球状标签云 canvas特效 烟花特效 知乎登陆背景 canva绘制时钟 一些炫酷的网站链接blacknegativeGeorge &amp; Jonathan III另一种烟花特效hugoware 3d特效网站three.jsI Remember","tags":[{"name":"css","slug":"css","permalink":"http://www.cmeng.cc/tags/css/"},{"name":"特效","slug":"特效","permalink":"http://www.cmeng.cc/tags/特效/"},{"name":"日志","slug":"日志","permalink":"http://www.cmeng.cc/tags/日志/"}]},{"title":"模块化与WebPack学习教程","date":"2017-02-24T16:27:12.000Z","path":"2017/02/25/index.md/webpack_jiao_cheng/","text":"模块化与WebPack学习教程本文主要介绍模块化以及打包工具WebPack的使用。关于webpack使用部分转载自简书-WebPack简明学习教程 by hutou 模块化 模块就是实现特定功能的文件。 模块化是一种处理复杂系统分解成为更好的可管理模块的方式，把系统代码划分为一系列职责单一，高度解耦且可替换的模块，提高系统的可维护性。 WebPack 一个打包工具 一个模块加载工具 各种资源都可以当成模块来处理 网站 http://webpack.github.io/ 如今，越来越多的JavaScript代码被使用在页面上，我们添加很多的内容在浏览器里。如何去很好的组织这些代码，成为了一个必须要解决的难题。 对于模块的组织，通常有如下几种方法： 通过书写在不同文件中，使用script标签进行加载 CommonJS进行加载（NodeJS就使用这种方式） AMD进行加载（require.js使用这种方式） ES6模块 思考：为什么只有JS需要被模块化管理，前台的很多预编译内容，不需要管理吗？ 基于以上的思考，WebPack项目有如下几个目标： 将依赖树拆分，保证按需加载 保证初始加载的速度 所有静态资源可以被模块化 可以整合第三方的库和模块 可以构造大系统 从下图可以比较清晰的看出WebPack的功能 WebPack的特点 丰富的插件，方便进行开发工作 大量的加载器，包括加载各种静态资源 代码分割，提供按需加载的能力 发布工具 WebPack的优势 webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。 WebPack的安装 安装命令 1$ npm install webpack -g 使用webpack 12$ npm init #会自动生产一个 package.json文件$ npm install webpack --save-dev #将webpack增加到package.json 文件中 可以使用不同的版本 1$ npm install webpack@1.2.x --save-dev 如果想安装开发工具 1$ npm install webpack-dev-server --save-dev WebPack的配置 每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。 下面是一个例子12345678910111213141516171819202122232425262728293031323334var webpack = require('webpack');var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : './src/js/page/index.js' &#125;, //入口文件输出配置 output: &#123; path: 'dist/js/page', filename: '[name].js' &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125;, //其它解决方案配置 resolve: &#123; root: 'E:/github/flux-example/src', //绝对路径 extensions: ['', '.js', '.json', '.scss'], alias: &#123; AppStore : 'js/stores/AppStores.js', ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125;&#125;; plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。 entry 是页面入口文件配置，output 是对应输出项配置 （即入口文件最终要生成什么名字的文件、存放到哪里） module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。 所有加载器需要使用npm来加载 最后是 resolve 配置，配置查找模块的路径和扩展名和别名（方便书写） WebPack开始使用 正确安装了WebPack，方法可以参考上面 书写entry.js文件 1document.write(\"看看如何让它工作！\"); 书写index.html文件 12345678&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\" src=\"bundle.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行命令，生成bundle.js文件 1$ webpack ./entry.js bundle.js 在浏览器中打开index.html文件，可以正常显示出预期 增加一个content.js文件 1module.exports = \"现在的内容是来自于content.js文件！\"; 修改entry.js文件 1document.write(require(\"./content.js\")); 执行第四步的命令 进行加载器试验 增加style.css文件 123body &#123;background: yellow;&#125; 修改entry.js文件 12require(\"!style!css!./style.css\");document.write(require(\"./content.js\")); 执行命令，安装加载器 1$ npm install css-loader style-loader # 安装的时候不使用 -g 执行webpack命令，运行看效果 可以在命令行中使用loader 1$ webpack ./entry.js bundle.js --module-bind \"css=style!css\" 使用配置文件默认的配置文件为webpack.config.js 增加webpack.config.js文件 123456789101112module.exports = &#123; entry: \"./entry.js\", output: &#123; path: __dirname, filename: \"bundle.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: \"style!css\" &#125; ] &#125;&#125;; 执行程序 1$ webpack 发布服务器 安装服务器 12$ npm install webpack-dev-server -g$ webpack-dev-server --progress --colors 服务器可以自动生成和刷新，修改代码保存后自动更新画面 1http://localhost:8080/webpack-dev-server/bundle","tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.cmeng.cc/tags/webpack/"},{"name":"模块化","slug":"模块化","permalink":"http://www.cmeng.cc/tags/模块化/"}]},{"title":"javascript 笔试题 续","date":"2016-11-15T14:26:41.000Z","path":"2016/11/15/index.md/Javascript_Written_Test_2/","text":"javascript 笔试题 续这些题目涉及对象的闭包,有万恶之源 this , 于是我把它们单独拉出一个板块，文章最后是我看完这些题之后含泪推荐一本书。。。 先来一道简单的开胃菜123456789101112131415var arr=[];function fun()&#123; for(var i=0;i&lt;4;i++)&#123; var x=&#123;&#125;; x.no=i; // 无关代码，可忽略 x.text=arr[i];// 无关代码，可忽略 x.fun=function()&#123;console.log(i)&#125;; arr.push(x); &#125;&#125;fun();arr[0].fun();arr[1].fun();arr[2].fun();arr[3].fun(); 分析： 12345fun() 执行结束之后： i = 4; arr数组中所有元素都是对象, 而对象中的fun为：function()&#123;console.log(i)&#125;; 所以所有输出都是 4 下面是主菜，主要涉及对 this和变量作用域的理解1234567891011121314151617window.a=300; function fn1()&#123; this.a=100; this.b=200; return function()&#123; alert(this.a); &#125;.call(arguments[0]); &#125; function fn2()&#123; this.a=new fn1(); //&#123;a:100,b:200&#125; &#125; var a=new fn1().b;//300 //a:200 var v=new fn1(fn2());//200 //a:&#123;a:100,b:200&#125;//[object Object] //v:&#123;a:100,b:200&#125; 提示： this指 调用 函数/属性的元素，或是 new 出的新元素，所有无主的 this 都指 window * 分析： 1234567891011121314第一步： var a = new fn1().b 1.1): new 完得到 &#123;a:100; b:200;&#125; return 的函数被 call()强行调用,由于没有传参 ==&gt; argument[0] = undefined,即call函数绑定 this 为 undefined ==&gt; this代表 window ==&gt; alert (wondow.a) ==&gt; 300; 1.2): var a = &#123;a:100; b:200;&#125;.b alert (200)第二步： var v = new fn1(fn2()) 2.1): 先执行 fn2() 函数: this.a = new fn1(); 注意：此处 this 指 window 且此时 window.a 由 1.2 改为 200; 同 1.1 ==&gt; alert(window.a) ==&gt; 200 最后 window.a =&#123;a:100; b:200;&#125;; 注意：没有返回值 ==&gt; 返回undefined 2.2): ==&gt; v = new fn1() ==&gt; alert(window.a) ==&gt; [object,Object] 运行效果：为了截图方便，alert 变为 console 输出 另一道主菜。。。12345678910111213141516171819202122var number=2;var obj=&#123; number:4, fn1:(function()&#123; // 此处 this 指window，执行后 window.number =&gt; 4 this.number*=2; // 无用代码，根据声明提前，此处number 为局部变量，无论此处如何操作都会在下一行重新赋值为3 // 不过此处不会报错，未经赋值， number 为 undefined number*=2; // ==&gt; number = NaN var number=3; return function()&#123; // this 指 window this.number*=2; number*=3; console.log(number); &#125; &#125;)() &#125; var fn1=obj.fn1; console.log(number); fn1(); obj.fn1(); 分析： 123456789101112131415执行自调函数 ==&gt; fn1 : function()&#123; // 此处 this 指window this.number*=2; // 此处 number 是闭包保护变量，值为 3 number*=3; console.log(number); &#125;第一步：var fn1 = obj.fn1; // 单纯引用，没有执行函数，不会有输出第二步：console.log(number); // 输出全局变量 number ==&gt; 4 : 在执行自调函数时改变第三步：fn1(); ==&gt; 输出闭包中的 number ==&gt; 3*3 ==&gt; 9第四步：obj.fn1(); ==&gt; 输出闭包中的 number ==&gt; 9*3 ==&gt; 27 注意：obj.fn1() 中的 this.number ==&gt; obj.number 运行效果 总结到此为止，所有的题目总结起来就是一个字“绕”，","tags":[{"name":"js","slug":"js","permalink":"http://www.cmeng.cc/tags/js/"},{"name":"前端笔试题","slug":"前端笔试题","permalink":"http://www.cmeng.cc/tags/前端笔试题/"},{"name":"闭包","slug":"闭包","permalink":"http://www.cmeng.cc/tags/闭包/"},{"name":"面向对象","slug":"面向对象","permalink":"http://www.cmeng.cc/tags/面向对象/"}]},{"title":"javascript 笔试题","date":"2016-11-15T14:26:37.000Z","path":"2016/11/15/index.md/Javascript_Written_Test/","text":"javascript 笔试题最近朋友给我推荐了几道关于javascript闭包和面向对象的面试题，兴冲冲的看了一下，本来就没想过会很简单，但是看完之后依然一脸懵逼，写这篇博客梳理一遍知识点同时也引以为戒。。。不过做完这些题之后不禁想到了一本书。。。 考点：变量作用域12345678var f=function()&#123;var a=b=1;&#125;;f();console.log(b); //1console.log(a); //报错var i,j=0,fn=function()&#123;var i=j=2;&#125;;fn();console.log(i,j);//undefined 2 知识点：js 中所有未定义直接使用的变量都默认为全局变量12345678910第一题: var a=b=1 的赋值方式被计算机理解为： var a=1; b=1; 结果：a是局部变量，b是全局变量 console输出未定义的变量 -&gt; 报错所以：不要使用 连续赋值第二题: j被当作全局变量重新赋值 i 是局部变量，对全局变量 i 没有影响，所以全局变量还是 未赋值 -&gt;undefined 考点：setTimeout 函数特性123var f=function()&#123;var a=b=1;&#125;;setTimeout(f,0);console.log(b);//报错 知识点： setTimeout 函数会在当前作用域中最后执行12在本题中，console.log(b)实际上会在 setTimeout()函数之前执行，因而在执行 console.log(b)时 b 是未定义的变量 ==&gt; 报错。 考点：闭包 -&gt; 取闭包保护的内容1234567891011var o=(function()&#123; var person=&#123; name:'eric', age:24 &#125;; return &#123; run:function(k)&#123; return person[k]; &#125; &#125;&#125;()); 问：不改变以上代码，如何获得闭包中的person 分析： 12345首先：自调函数执行完之后的返回值赋值给 变量 o 所以 o = &#123;run : function(k)&#123; return person[k]; &#125;&#125; person = &#123;name:&apos;eric&apos;,age:24&#125; 解决办法 定义访问器属性 返回自身 闭包函数调用自定义属性 有必要先说一下 Object.defineProperty 的用法： 语法 Object.defineProperty(object, propertyname, descriptor) 参数 * object * 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。 propertyname 必需。 一个包含属性名称的字符串。 descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。 返回值 已修改对象。Object.defineProperty 用法传送门 12345678910 Object.defineProperty(Object.prototype,\"self\",&#123; get:function()&#123;return this;&#125;&#125;);var person_copy=o.run(\"self\");// 测试var person_copy=o.run(\"self\");console.log(o.run(\"age\")); // 24 =&gt; 闭包保护数据person_copy.age=-2;console.log(o.run(\"age\")); // -2 成功修改闭包 // TODO ： 原理// 个人对 Object.defineProperty 的了解不深 考点 ：闭包 函数####先来一道简单的打底123456789var a=0,b=0;var A=function(a)&#123; A=function(b)&#123; console.log(a+b++); &#125; console.log(a);&#125;A(1);//1A(12);//13 分析： 123451.1): A(1) --&gt; 首次执行，A被重新赋值，输出参数 1，运行结束后： A = function(b)&#123; // 此时变量 a=1 已被闭包保护 console.log( a + b++); &#125;1.2): A(12) --&gt; console.log(a + 12++); ==&gt; 输出 13 运行效果： 下面才是正餐：1234567891011121314function fun(n,o)&#123; console.log(o); return&#123; fun:function(m)&#123; return fun(m,n); &#125; &#125; &#125; var a=fun(0); a.fun(1); a.fun(2); a.fun(3); //undefined 0 0 0 var b=fun(0).fun(1).fun(2).fun(3); //undefined 0 1 2 var c=fun(0).fun(1); c.fun(2); c.fun(3); //undefined 0 1 1 提问：三行代码输出的结果分别是什么 分析： 12345678910111213141516171819202122232425262728第一行： 1.1): var a = fun(0) =&gt; 并没有传出参数 o =&gt; 输出 undefined， a = &#123; // 此时参数 n=0 已被闭包保护 fun:function(m)&#123; return fun(m,n); &#125; 1.2): a.fun(1) ==&gt; function(m=1)&#123; return fun(m,n);&#125; 输出闭包变量 n 的值，即 0; 而调用过程并没有修改变量 n, 所以 n = 0 ==&gt; a.fun(2) 输出 0 ==&gt; a.fun(3) 输出 0 ... ==&gt; a.fun(x) 输出 0第二行: 2.1): 同 1.1 2.2): b.fun(1) ==&gt; function(m=1)&#123; return fun(m,n=0);&#125; ==&gt; 输出 n ,即 0 b = &#123; // 此时 n 依然被闭包保护，不过值变为新的参数 1， fun:function(m)&#123; return fun(m,n &lt;== 1); &#125; 2.3): 类似 2.2 推导， 输出：1，闭包变量 n = 2; 可得：本题链式调用每次输出闭包变量 n 值，n 的值为上次调用传入的参数 ... .fun(x-1).fun(x) ==&gt; 最后输出 x-1第三行： 3.1): 同 2.1,2.2; 运行结束后：闭包变量 n -&gt; undefined -&gt; 0 -&gt; 1 3.2): 同 1.2, 单步调用不修改变量 n, ==&gt; 一直输出 变量 n=&gt;1 运行结果 未完待续。。。","tags":[{"name":"js","slug":"js","permalink":"http://www.cmeng.cc/tags/js/"},{"name":"前端笔试题","slug":"前端笔试题","permalink":"http://www.cmeng.cc/tags/前端笔试题/"},{"name":"闭包","slug":"闭包","permalink":"http://www.cmeng.cc/tags/闭包/"}]},{"title":"记首次使用hexo的尴尬历程","date":"2016-09-21T07:03:51.000Z","path":"2016/09/21/index.md/The_awkward_experience_of_first_use_Hexo/","text":"记首次使用hexo的尴尬历程2016年9月19号，第一次听说Hexo。据说用这个框架可以很快搭建出一个漂亮的博客，正好朋友有这方面的需求，于是第二天尝试了一下，嗯，效果挺好，不过遇到一些坑。。。我使用的主题是 Yelee，Hexo主题传送门 坑1 : 站内搜索本来一行命令就可以解决的事到我这边却莫名其妙的出了问题。。。 1npm install --save hexo-generator-search 最让我恼火的是不知道什么原因就好了，感觉一个多小时的查找都付之东流了。。。不过我发现这个主题在手机和平板的竖屏状态下是没有搜索栏的，看了一下代码发现作者把搜索栏放到了左边栏的位置，竖屏后不好调整代码位置，索性直接隐藏了。我想尝试将搜索框完善一下，不过这样要改动的地方不会少，漫漫长路。。。 坑2 : tag 云文档创建tags文件,生成一个index.md文件，按文档所说（后来才知道我以为的并不是我以为的T_T）标签云在index.md文件中生成，于是我就把所有标签定义在index.md文件中，由此开启了悲惨之旅。。。 1hexo new post tags 正确的理解是：tags中的index.md会集中显示标签，同时又不需要在index.md文件中定义任何标签，因为模板会将所有文件中的标签整合，去重，然后在tags里显示。没错，事实是tags的index.md文件就是单纯的显示模块，而我花了一个多小时的时间去尝试改变标签的定义方式，标签云的引用，甚至于标签云样式的定义。。。表示已经哭晕在厕所。。。 坑3 : 上传历经重重艰辛，终于到了上传的时刻。满怀期待的输入了 hexo d ,Duang 的一下就弹出了一堆警告，仔细一看是编码问题：windows的CRLF,linux的LF，两家一直不对付，不过好在不影响效果,也就无所谓了。然而紧接着就是一个华丽的报错： 12Error: bash: /dev/tty/:No such device or addresserror: failed to execute proment script (exit code 1) 在网上折腾半小时之后我才想起来用的 ssh 上传到 github, _config.yml 文件的配置里居然用的 https,被自己蠢哭了。。。 1234deploy: type: git repo: https://github.com:xxx/xxx.xxx.io.git branch: [master] 正确配置： 1234deploy: type: git repo: git@github.com:xxx/xxx.xxx.io.git branch: [master] 问题解决，继续上传， hexo d ,还是老一套的警告，没有报错证明确实是配置文件的协议有问题，然而就在我等这下文的时候它却华丽丽的停下了！没错，没有一点点防备的停下了，没有开始上传的提示，也没有报错，就这么停了。。。当时我就懵逼了，不过经历一下午的坎坷，抗打击能力确实有所提高。。。话说我应该高兴吗。。。我决定等一等再说，不管是电脑卡了还是网络延迟又或者是后台传输（当然这是最好的情况）都不宜强行中断，而且当时网络确实不咋地。终于在我吃完饭之后看到了成功的讯号。。。话说时间也太长了吧。。。 顺带提一句，我的同学告诉我hexo-deployer-git 插件使用ssh上传内容到github,但同时这个插件却没有输入密码的部分，因此总是报错：权限不足，于是他告诫我ssh不要有密码。我将ssh密码置为空之后果然没有出现他所说的报错。但是从程序员的角度来说，虽然ssh本身有一层加密，但不能设密码这一点算是个小缺点。事实上本人并没有亲自试过能不能带密码上传，同学的错误代码也没有保留下来，因此希望有志之士试过之后告诉我。。。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.cmeng.cc/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.cmeng.cc/tags/github/"}]},{"title":"jquery小记","date":"2016-09-20T06:53:15.000Z","path":"2016/09/20/index.md/jquery/","text":"jQueryjQuery: $(document).ready(function(){…}) VS DOM: window.onload=function(){…}ready 的底层事件：DOM中的ondocumentcontentloaded:只要DOM树加载完成，就会触发window.onload 在页面全部加载完成之后触发 大致流程如图所示： 举例测试12345678910111213141516171819&lt;body&gt; &lt;h1&gt;页面加载完成事件&lt;/h1&gt; &lt;script&gt; console.time(\"docReady\"); console.time(\"winLoad\"); &lt;/script&gt; &lt;script src=\"../jquery-1.11.3.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function()&#123; console.log(\"window.onload...\"); console.timeEnd(\"winLoad\"); &#125; $(document).ready(function($) &#123; console.log(\"document ready...\"); console.timeEnd(\"docReady\"); &#125;); &lt;/script&gt; &lt;/body&gt; 执行结果 &nbsp;&nbsp;事实上：将script放在body结尾也能实现 ready 的功能：12345678910111213141516&lt;body&gt; &lt;h1&gt;页面加载完成事件&lt;/h1&gt; &lt;script&gt; console.time(\"docReady\"); console.time(\"winLoad\"); &lt;/script&gt; &lt;script src=\"../jquery-1.11.3.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function()&#123; console.log(\"window.onload...\"); console.timeEnd(\"winLoad\"); &#125; console.log(\"document ready...\"); console.timeEnd(\"docReady\"); &lt;/script&gt; &lt;/body&gt; 显示/隐藏&nbsp;&nbsp;jQuery中有 show()，hide()控制内容的显示和隐藏，但只能完成一个功能toggle()函数可以同时完成显示和隐藏的功能在不加参数的情况下：show(),hide(),toggle() 函数通过改变元素的 display 属性实现显示和隐藏，没有动画效果加上参数：函数设置 overflow:hidden,通过将元素的 width，height和opacity属性逐渐变为 0 实现过度效果 动画函数 animate()&nbsp;&nbsp; $(…).animate(parmes,speed,easing,fn)参数： parmes: css属性的目标值：{属性:值,属性:值 … } 注意： css 属性名要去横线,变驼峰;值是字符串而且要加单位 ==&gt;marginLeft:’12px’ speed: 速度：数字（单位：ms）/字符串”slow/normal/fast” easing: 过度方式：linear(匀速)，ease(慢到快)。。。动画中的排队和并发(串行和并行)一个 animate 函数中修改的属性会同时修改，多个 animate 函数时会等前一个动画变换完再变换。 1$(...).animate(&#123;width:'200px',height:'200px'&#125;,1000); 执行效果：该元素的宽和高在1秒内都变为200px 1$(...).animate(&#123;width:'200px'&#125;,1000).animate(&#123;height:'200px'&#125;,2000); 执行效果：该元素的宽在1秒内都变为200px后，高在2秒内变为200px js回调函数中的 this 指window，animate函数中的回调函数指当前对象","tags":[{"name":"jquery","slug":"jquery","permalink":"http://www.cmeng.cc/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"http://www.cmeng.cc/tags/javascript/"}]}]